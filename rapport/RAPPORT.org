#+title: Support MPI/OpenMP et de la vectorisation dans Verificarlo
#+author: Safecarlo
#+date: 2020

* Verificarlo

  [[https://github.com/verificarlo/verificarlo][Verificarlo]] est un compilateur basé sur *clang* et *llvm*. Il
  permet d'intercepter toutes les opérations flottantes et de les
  analyser. Ce qui permet dans le cadre du calcul scientifique et de
  la simulation de pouvoir débugger, valider et optimiser ces
  opérations ainsi que leurs formats.

* Organisation
** Groupe

   Nous nous somme répartis en 2 groupe:
   - un groupe sur la partie [[https://www.mpich.org/][MPI]] / [[https://www.openmp.org/][OpenMP]] ainsi que la génération de
     nombre aléatoire (Hery Andrianantenaina / Julien Even)
   - un groupe sur le support de la vectorisation dans Verificarlo
     (Nicolas Bouton / Ali Lakbal)

** Git

   Etant donné que *Verificarlo* est un logiciel ayant un dépôt
   distant sur le site [[https://github.com][GitHub]]. Nous avons décidé de créer une
   Organisation sur *GitHub* et de *fork* Verificarlo dans notre
   Organisation. Nous avons également chacun *fork* Verificarlo depuis
   notre le *fork* de notre Organisation.

   Lien vers notre fork de verificarlo: [[https://github.com/Safecarlo/verificarlo/tree/vectorization][Safecarlo]]
   
** Réunion avec l'encadrant

   Nous avoins une réunions toutes les semaines le mardi matin avec
   notre encadrant pour faire le point sur l'avancement de la semaine.

* Support MPI / OpenMP
* Génération de nombre aléatoire
* Vectorisation
** Résumé des besoins

   Aujourd’hui *vfcinstrument* insert des probes, y compris pour les
   instruction vectorielles.

   Les probes sont des fonctions implémenté dans *vfcwrapper* qui
   est linker avec le programme par la partie compilation de veificarlo.

   Celles des instructions vectorielles defont le vecteur et appel les
   versions scalaires au lieu d'appeler les fonctions vectorielles des
   backends.

   A l’exécution le *wrapper* charge (load) les librairies dynamiques (.so)
   correspondantes au(x) *backend(s)* verificarlo utilisé (vprec, mca).

** Définitions de certains termes technique

   *probes :* Les probes sont des fonctions implémenté dans
   *vfcwrapper* qui est linker avec le programme par la partie
   compilation de veificarlo.

   *backend :* Dans le cadre de verifcarlo, c'est la/les librairie(s)
   dynamique(s) qui seront appelées par le wrapper dans les
   probes. Dans le cadre d'un compilateur c'est la derniere phase qui
   descend de la représentation intermédiaire vers le binaires (en
   général).

   *wrapper :* Ce sont des fonctions qui enveloppent l'appel à
   d'autres fonctions.

   *link :* Il s'agit de la phase de compilation qui consiste à aller
   chercher toute les librairies externes appelé par l'application
   pour les liées au programe utilisateur afin de resoudre les
   références non défini.

   *sérialisation :* Dans le contexte de l'utilisation de vecteur il
   s'agit d'éxécuter en séquence les éléments du vecteur.

** Objectifs
   
   Les changements sont à faire essentiellement dans les *wrappers* et
   les *backends*:

   1. Support des vecteurs de 512 et 256 bits
   2. Ajout de *probes* vectorielles appellant les fonctions de
      *backend* vectorielles
      - Ajout des fonctions vectorielles dans l'interfaces (par
        pointeurs)
   3. Implémenter ces fonctions pour chaque *backend*
      - Faire une première implémentation sérialisé
   4. Implémenter la version vectorielle des opérations de base dans
      le backends *vprec*
      - Prendre en compte les cas spéciaux (dénormaux)
      - Tester la performance sur les [[https://www.nas.nasa.gov/publications/npb.html][NAS]] (MPI et OpenMP)
   5. Faire de même pour le *backend mca*

** Schéma

   Voici un schéma qui explique les différents processus pour établir
   la vectorisations dans verificarlo :

   [[./scheme.png]]

** Test

   Pour les test, nous avons décidé de suivre le fonctionnement de
   test que verificarlo à commencé à implémenter. C'est-à-dire que
   nous ne ferons pas de *tests unitaires* mais nous testerons si les
   résultatus obtenu lors de la *compilation* et de l'exécution sont
   exactes.

   Nous devons testé 3 choses:
   - le bon résultat des opérations vecorielles
   - l'appel aux *probes vectorielles*
   - l'utilisation des jeux d'instructions vectorielles suivant l'arhitecture

** Support des vecteurs 512 / 256 bits

   Les vecteurs 512 / 256 bits était déjà supporté.

   Verificarlo utilise les types vectorielles de [[https://clang.llvm.org/docs/LanguageExtensions.html#vectors-and-extended-vectors][clang]].

** Ajout de probes vectorielles

   Les probes vectorielles était déjà implémenté mais appelais les
   probes scalaires.

   Nous avons donc dû modifié les probes en appelant les fonctions
   vectorielles des backends.

   De plus nous avons factorisé la macro qui permet de définir les
   probes vecorielles en *1* macro au lieu de *4* (une pour chaque
   taille) en passant la taille en paramètre.

** Ajout des fonctions vectorielles dans l'interface

   Il nous faut d'abord identifier quelle est l'interface et où la
   trouver. Nous avons facilement trouver où et comment la
   modifier. L'interface se trouve dans le fichier
   *src/common/inteflop.h*.

   Nous avons décidé de mettre la taille en argument pour évité de
   faire une fonction pour chaque taille en plus d'une fonction pour
   chaque opération et pour chaque précision. Ce qui nous fait un
   total de 8 fonctions à ajouté au lieu de 32.

   Comme nous passons la taille en argument, il faudra testé la
   taille pour permettre à clang d'effectuer une opération vectorielle
   en castant notre tableau dans le bon type vectorielles de clang.

   Par exemple si nous avons une opération flottante avec une
   précision *double*, avec l'opération *add* et un taille de vecteur
   de *4* nous devrons faire l'instruction suivante:

#+BEGIN_SRC c

(*(double4 *)c) = (*(double4 *)a) + (*(double4 *)b);

#+END_SRC

   En ce qui concerne le type des opérandes, nous avons décidé de
   casté le type vectorielles en son pointeur sur sa
   précision. Reprenons l'exemple ci-dessus, pour un type *double4*
   nous le casterons sont pointeur en un pointeur de *double*.

   _Règle:_ adr precision##size -> adr precision

   Nous pouvons faire cela car lors de la définitions des types
   vectorielles, il est précisé qu'un type *precision##size* est de type
   *precission*.

** Fonctions vectorielles en mode scalaire dans les *backends*

   Pour les fonctions *vectorielles* en mode scalaire, il suffit de
   prendre le code des fonctions *scalaires* et de faire un boucle sur
   chaque élément du tableau. Ceci est applicable pour tout les
   *backends*.

** Fonctions vectorielles en mode vectorielles dans les *backends*
*** Backend ieee
*** backend vprec
*** Backend mca
