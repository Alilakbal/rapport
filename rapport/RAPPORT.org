#+title: Support de MPI/OpenMP et de la vectorisation dans Verificarlo
#+author: Safecarlo
#+date: 2020

* Verificarlo

  [[https://github.com/verificarlo/verificarlo][Verificarlo]] est un compilateur basé sur *clang* et *llvm*. Il
  permet d'intercepter toutes les opérations flottantes et de les
  analyser. Ce qui permet dans le cadre du calcul scientifique et de
  la simulation de pouvoir déboguer, valider et optimiser ces
  opérations ainsi que leurs formats.

  Les opérations flottantes ont un intérêt particulier dans le monde
  du *HPC* (High Performance Computing). Elles peuvent être source
  d'erreur sans pour autant être un problème mathématiques. En effet
  dans le domaine de l'informatique, les ordinateurs ont une
  limitation matérielle qui ne leur permet pas d'atteindre une
  certaine précision.

  C'est là qu'intervient *Verificarlo*, cet outil permet par
  instumentation des opérations flottantes, de pouvoir déboguer 
  les erreurs dû à la précision machine. Par exemple de pouvoir
  modifier la taille maximale de l'exposant ou bien de la mantise. Ou
  bien même de pour voir effectuer des opérations flottantes en
  ajoutant du bruit au résultat afin de simuler une précision machine
  plus élevé.

** Parralélisme dans le calcul scientifique
** Vectorisation dans le calcul scientifique

   

* Organisation
** Groupe

   Nous nous somme répartis en 2 groupe:
   - un groupe sur la partie [[https://www.mpich.org/][MPI]] / [[https://www.openmp.org/][OpenMP]] ainsi que la génération de
     nombre aléatoire (Hery Andrianantenaina / Julien Even)
   - un groupe sur le support de la vectorisation dans Verificarlo
     (Nicolas Bouton / Ali Lakbal)

** Git

   Etant donné que *Verificarlo* est un logiciel ayant un dépôt
   distant sur le site [[https://github.com][GitHub]]. Nous avons décidé de créer une
   Organisation sur *GitHub* et de *fork* Verificarlo dans notre
   Organisation. Nous avons également chacun *fork* Verificarlo depuis
   notre le *fork* de notre Organisation.

   Lien vers notre fork de verificarlo: [[https://github.com/Safecarlo/verificarlo/tree/vectorization][Safecarlo]]
   
** Réunion avec l'encadrant

   Nous avoins une réunions toutes les semaines le mardi matin avec
   notre encadrant pour faire le point sur l'avancement de la semaine.

* Support MPI / OpenMP
* Génération de nombre aléatoire
* Vectorisation
** Résumé des besoins

   Aujourd’hui *vfcinstrument* insert des probes, y compris pour les
   instruction vectorielles.

   Les probes sont des fonctions implémenté dans *vfcwrapper* qui
   est linker avec le programme par la partie compilation de veificarlo.

   Celles des instructions vectorielles defont le vecteur et appel les
   versions scalaires au lieu d'appeler les fonctions vectorielles des
   backends.

   A l’exécution le *wrapper* charge (load) les librairies dynamiques (.so)
   correspondantes au(x) *backend(s)* verificarlo utilisé (vprec, mca).

** Définitions de certains termes technique

   *probes:* Les probes sont des fonctions implémenté dans
   *vfcwrapper* qui est linker avec le programme par la partie
   compilation de veificarlo.

   *backend:* Dans le cadre de verifcarlo, c'est la/les librairie(s)
   dynamique(s) qui seront appelées par le wrapper dans les
   probes. Dans le cadre d'un compilateur c'est la derniere phase qui
   descend de la représentation intermédiaire vers le binaires (en
   général).

   *wrapper:* Ce sont des fonctions qui enveloppent l'appel à
   d'autres fonctions.

   *link:* Il s'agit de la phase de compilation qui consiste à aller
   chercher toute les librairies externes appelé par l'application
   pour les liées au programe utilisateur afin de resoudre les
   références non défini.

   *sérialisation:* Dans le contexte de l'utilisation de vecteur il
   s'agit d'éxécuter en séquence les éléments du vecteur.

** Objectifs
   
   Les changements sont à faire essentiellement dans les *wrappers* et
   les *backends*:

   1. Support des vecteurs de 512 et 256 bits
   2. Ajout de *probes* vectorielles appellant les fonctions de
      *backend* vectorielles
      - Ajout des fonctions vectorielles dans l'interfaces (par
        pointeurs)
   3. Implémenter ces fonctions pour chaque *backend*
      - Faire une première implémentation sérialisé
   4. Implémenter la version vectorielle des opérations de base dans
      le backends *vprec*
      - Prendre en compte les cas spéciaux (dénormaux)
      - Tester la performance sur les [[https://www.nas.nasa.gov/publications/npb.html][NAS]] (MPI et OpenMP)
   5. Faire de même pour le *backend mca*

** Schéma

   Voici un schéma qui explique les différents processus pour établir
   la vectorisations dans verificarlo :

   [[./scheme_2.png]]

** Test

   Pour les test, nous avons décidé de suivre le fonctionnement de
   test que verificarlo à commencé à implémenter. C'est-à-dire que
   nous ne ferons pas de *tests unitaires* mais nous testerons si les
   résultatus obtenu lors de la *compilation* et de l'exécution sont
   exactes.

   Les *tests* sont principalement écrit en *bash* et un code
   *c*. Les *tests* se trouvent dans le répertoire
   =tests/test_vector_instrumentation/=. 

   Nous devons testé 3 choses:
   - le bon résultat des opérations vecorielles
   - l'appel aux *probes vectorielles*
   - l'utilisation des jeux d'instructions vectorielles suivant l'arhitecture

*** Bon résultat des opérations vectorielles

    Pour ce faire nous devons itérer sur tout les backends, toutes les
    précisions et toutes les tailles de vecteurs et s'assurer du bon
    résultat à l'aide d'un fichier contenat le résultat attendu que
    l'on comparera avec la sortie de notre programme.

*** Appel aux probes vectorielles

    Pour ce faire nous devons récupérer les fichiers *.ll* en
    compilant avec *--save-temps* qui sont la représentations
    intermédiaires de notre programme de test.

    Un fois récupérer il nous suffit de vérifier si l'appel aux
    *probes vectorielles* sont bien effectué.

*** Utilisation des jeux d'instructions vectorielles suivant l'arhitecture

    Pour ce dernier sous-test, nous supposont que le test s'effectue
    sur une machine *x86_64* tournant sur *Linux*.

    Suivant les jeux d'instructions disponnible sur la machine, le
    test vérifie si les jeux d'instructions sont bien utilisés.

    _Par exemple:_ si nous avons uniquement les jeux d'instruction
    *sse* et *avx*, nous devrions avoir des instructions *sse* pour
    les types vectorielles *float2*, *float4* et *double2*. Et des
    instruction *avx* pour tous les autres types vecorielles.

    Cependant notre test, test uniquement si ces instructions sont
    utilisé au moins une fois et ne compte pas exactement combien de
    fois elles sont utilisé. Nous supposons donc que *clang* et *llvm*
    vectorisent bien nos opérations.

** Support des vecteurs 512 / 256 bits

   Les vecteurs 512 / 256 bits était déjà supporté.

   Verificarlo utilise les types vectorielles de [[https://clang.llvm.org/docs/LanguageExtensions.html#vectors-and-extended-vectors][clang]].

** Ajout de probes vectorielles

   Les probes vectorielles était déjà implémenté mais appelais les
   probes scalaires.

   Nous avons donc dû modifié les probes en appelant les fonctions
   vectorielles des backends.

   De plus nous avons factorisé la macro qui permet de définir les
   probes vecorielles en *1* macro au lieu de *4* (une pour chaque
   taille) en passant la taille en paramètre.

** Ajout des fonctions vectorielles dans l'interface

   Il nous faut d'abord identifier quelle est l'interface et où la
   trouver. Nous avons facilement trouver où et comment la
   modifier. L'interface se trouve dans le fichier
   *src/common/inteflop.h*.

   Nous avons décidé de mettre la taille en argument pour évité de
   faire une fonction pour chaque taille en plus d'une fonction pour
   chaque opération et pour chaque précision. Ce qui nous fait un
   total de 8 fonctions à ajouté au lieu de 32.

   Comme nous passons la taille en argument, il faudra testé la
   taille pour permettre à clang d'effectuer une opération vectorielle
   en castant notre tableau dans le bon type vectorielles de clang.

   Par exemple si nous avons une opération flottante avec une
   précision *double*, avec l'opération *add* et un taille de vecteur
   de *4* nous devrons faire l'instruction suivante:

#+BEGIN_SRC c

(*(double4 *)c) = (*(double4 *)a) + (*(double4 *)b);

#+END_SRC

   En ce qui concerne le type des opérandes, nous avons décidé de
   casté le type vectorielles en son pointeur sur sa
   précision. Reprenons l'exemple ci-dessus, pour un type *double4*
   nous le casterons sont pointeur en un pointeur de *double*.

   _Règle:_ adr precision##size -> adr precision

   Nous pouvons faire cela car lors de la définitions des types
   vectorielles, il est précisé qu'un type *precision##size* est de type
   *precission*.

** Fonctions vectorielles en mode scalaire dans les *backends*

   Pour les fonctions *vectorielles* en mode scalaire, il suffit de
   prendre le code des fonctions *scalaires* et de faire un boucle sur
   chaque élément du tableau. Ceci est applicable pour tout les
   *backends*.

** Fonctions vectorielles en mode vectorielles dans les *backends*
*** Backend ieee

    Pour le *backend* ieee, il n'y pas de traitement particulier sur
    les opérations. Le *backend* effectue l'opération et la debug.

    Pour vectorisé l'opération comme di précedement il faut recasté le
    pointeur de la *precision* flottante en type vectorielles de
    clang. Pour cela nous avons créer une macro c qui nous le
    permet. Le seul désavantage est que l'on effectue un branchement à
    cause de la condition.

    Pour la fonction de debuggage, elle est essentiellement composé de
    sortie standart ou dans un fichier ce qui n'est pas
    vectorisable. Donc nous avons laisser la boucle qui appelle la
    fonction de debug pour chaque élément du tableau.

*** backend vprec
*** Backend mca
** Vérification si au moins un backend utilisé implémente les opérations vectorielles

   Pour l'instant seul les backends *ieee*, *vprec* et *mca* ont été
   modifié et implémente les opérations vectorielles de façons
   scalaire ou vectorielles.

   Pour les autres backends, la version scalaire n'est même pas
   implémenté.

   Comme pour les opérations scalaires, nous avons ajoutés dans la
   fonctions d'initialisations des *probes* le fait de vérifier si au
   moins un *backend* utilisé implémente les opérations vectorielles.

   Ceci bloque tout les backends qui ne les implémentent pas. Mais une
   sérialisation peut très vite être faites.
