#+TITLE: Rapport Second Semestre pour le support de la Vectorisation
#+AUTHOR: Sholde
#+DATE: 2021

* Vectorisation du backend *vprec*

  Ce backend permet de gérer les cas des *dénormaux* et des nombres
  *infinis*. Cepandant ces cas restes rares dans les codes de calculs. C'est
  pourquoi nous avons décidé de priorisé la vectorisation pour les cas des
  *normaux*.

** Petit rappel des cas spéciaux

   Prenons comme exemple une précision de 3 et une taille de 2 pour un type flottant.
   - *cas normal:* exposant compris entre -1 et 1.
   - *cas dénormal:* exposant compris entre -2 et -4. Le bit de l'exposant est
     implicite et seul les valeur de la mantisse compte. Or ici la mantisse à 3
     bits, donc le cas des dénormaux s'étend sur 3 bits d'exposant.
   - *cas infinis:* exposant < -4 et exposant > 1.

   #+CAPTION: Rappel des cas spéciaux
   #+NAME: fig:rappel_des_cas_speciaux
   #+ATTR_LATEX: :width 200px
   [[../ressources/special_case.png]]

** Stuctures

   Le backend utilise des structures pour faciliter la compréhension des
   calculs. Or les structures comportent des types scalaires. Il faut donc créer
   de nouvelles structures pour les types vectorielles que proposent *clang*.

*** Flottant simple précision
**** Version scalaire

#+BEGIN_SRC c
typedef union {

  float f32;
  uint32_t u32;
  int32_t s32;

  /* Generic fields */
  float type;
  uint32_t u;

  struct {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
    uint32_t sign : FLOAT_SIGN_SIZE;
    uint32_t exponent : FLOAT_EXP_SIZE;
    uint32_t mantissa : FLOAT_PMAN_SIZE;
#endif
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    uint32_t mantissa : FLOAT_PMAN_SIZE;
    uint32_t exponent : FLOAT_EXP_SIZE;
    uint32_t sign : FLOAT_SIGN_SIZE;
#endif
  } ieee;

} binary32;
#+END_SRC

**** Version vectorielles

     Nous avons un problèmes car nous ne pouvant pas assigner une valeur par
     défault à un type vectoriel de *clang* dans une structure. On ne peut
     également pas initialisé ces arguments dans la fonction d'initialisation du
     backend *vprec* car ils font partis d'une structure et il faut que lorsque
     l'on créer cette structure n'importe ou dans le code, on puisse avoir les
     valeurs par défault. Donc la structure ci-dessous ne fonctionne pas.

#+BEGIN_SRC c
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__

#define define_binary32_vector(size)                                           \
  typedef union {                                                              \
                                                                               \
  float##size f32;                                                             \
  int##size u32;                                                               \
  int##size s32;                                                               \
                                                                               \
  /* Generic fields */                                                         \
  float##size type;                                                            \
  int##size u;                                                                 \
                                                                               \
  struct {                                                                     \
    int##size sign : FLOAT_SIGN_SIZE;                                          \
    int##size exponent : FLOAT_EXP_SIZE;                                       \
    int##size mantissa : FLOAT_PMAN_SIZE;                                      \
  } ieee;                                                                      \
                                                                               \
  } binary32_x##size;

#endif

#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__

#define define_binary32_vector(size)                                           \
  typedef union {                                                              \
                                                                               \
    float##size f32;                                                           \
    int##size u32;                                                             \
    int##size s32;                                                             \
                                                                               \
    /* Generic fields */                                                       \
    float##size type;                                                          \
    int##size u;                                                               \
                                                                               \
    struct {                                                                   \
      int##size mantissa : FLOAT_PMAN_SIZE;                                    \
      int##size exponent : FLOAT_EXP_SIZE;                                     \
      int##size sign : FLOAT_SIGN_SIZE;                                        \
    } ieee;                                                                    \
                                                                               \
  } binary32_x##size;

#endif

define_binary32_vector(2);
define_binary32_vector(4);
define_binary32_vector(8);
define_binary32_vector(16);
#+END_SRC

*** Flottant double précision

    En attente de la fin de la vectorisation des flottants simple précision.

** Fonctions

   Pour ce qui est des fonctions, elles utilisent elles aussi des types
   scalaires. Il faut donc créer des fonctions utilisant les types vectorielles.

*** Flottant simple précision

    Comme nous passons la taille du vecteur en paramètre il faut donc que l'on
    appelle la bonne fonction suivant la taille du vecteur.

    Pour ce qu'il est du calcul, c'est juste un calcul de vecteur comme dans le
    backend *ieee*.

#+BEGIN_SRC c
static inline void _vprec_binary32_binary_op_vector(const int size, float *a,
                                                    float *b, float *c,
                                                    const vprec_operation op,
                                                    void *context) {
  if ((VPRECLIB_MODE == vprecmode_full) || (VPRECLIB_MODE == vprecmode_ib)) {
    switch (size)
      {
      case 2:
        _vprec_round_binary32_float2(a, 1, context, VPRECLIB_BINARY32_RANGE,
                                     VPRECLIB_BINARY32_PRECISION);
        _vprec_round_binary32_float2(b, 1, context, VPRECLIB_BINARY32_RANGE,
                                     VPRECLIB_BINARY32_PRECISION);
        break;
      case 4:
        _vprec_round_binary32_float4(a, 1, context, VPRECLIB_BINARY32_RANGE,
                                     VPRECLIB_BINARY32_PRECISION);
        _vprec_round_binary32_float4(b, 1, context, VPRECLIB_BINARY32_RANGE,
                                     VPRECLIB_BINARY32_PRECISION);
        break;
      case 8:
        _vprec_round_binary32_float8(a, 1, context, VPRECLIB_BINARY32_RANGE,
                                     VPRECLIB_BINARY32_PRECISION);
        _vprec_round_binary32_float8(b, 1, context, VPRECLIB_BINARY32_RANGE,
                                     VPRECLIB_BINARY32_PRECISION);
        break;
      case 16:
        _vprec_round_binary32_float16(a, 1, context, VPRECLIB_BINARY32_RANGE,
                                      VPRECLIB_BINARY32_PRECISION);
        _vprec_round_binary32_float16(b, 1, context, VPRECLIB_BINARY32_RANGE,
                                      VPRECLIB_BINARY32_PRECISION);
        break;
      default:
        break;
      }
  }

  perform_vector_binary_op(float, size, op, c, a, b);

  if ((VPRECLIB_MODE == vprecmode_full) || (VPRECLIB_MODE == vprecmode_ib)) {
    switch (size)
      {
      case 2:
        _vprec_round_binary32_float2(c, 0, context, VPRECLIB_BINARY32_RANGE,
                                     VPRECLIB_BINARY32_PRECISION);
        break;
      case 4:
        _vprec_round_binary32_float4(c, 0, context, VPRECLIB_BINARY32_RANGE,
                                     VPRECLIB_BINARY32_PRECISION);
        break;
      case 8:
        _vprec_round_binary32_float8(c, 0, context, VPRECLIB_BINARY32_RANGE,
                                     VPRECLIB_BINARY32_PRECISION);
        break;
      case 16:
        _vprec_round_binary32_float16(c, 0, context, VPRECLIB_BINARY32_RANGE,
                                      VPRECLIB_BINARY32_PRECISION);
        break;
      default:
        break;
      }
  }
}
#+END_SRC

*** Flottant double précision

    En attente des résultat des simples précision.

*** Rounding
*** Cas Normal
