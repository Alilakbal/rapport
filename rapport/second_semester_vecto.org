#+TITLE: Rapport Second Semestre pour le support de la Vectorisation
#+AUTHOR: Sholde
#+DATE: 2021

* Introduction

  Ce rapport fait suite au précédent. Les informations rédigé sur le prédécent
  rapport doivent donc être comprisent afin de pouvoir comprendre la suite du
  rapport.

* Support de la parallélisation
* Support de la vectorisation
** Point git

   Durant le semestre, des modifications ont été apporté sur la branche master
   de *verificarlo*. Pour ne pas être trop éloigner de la version scalaire de
   cette branche nous avons donc décidé de rappatrier les modifications sur
   notre branches master de notre fork.

   Le problème étant que nous avons utilisé la stratégie par fusion (qui était
   par défault) au lieu de faire un rebasage afin de grouper les modifications
   (commits) au lieu de les éparpiller.
   
** Ajout du compte des opérations flottantes vectorielles dans le backend *ieee*
** Vectorisation du backend *vprec*

   Ce backend permet de gérer les cas des nombres spéciaux comme les nombres
   *dénormaux* et les nombres *infinis*. Cepandant ces cas restent rares dans les
   codes de calculs. C'est pourquoi nous avons décidé de priorisé la
   vectorisation pour les cas des nombres *normaux*.

*** Petit rappel des cas spéciaux (A revoir)

    Prenons comme exemple une précision de 3 et une taille de 2 pour un type flottant.
    - *cas normal:* exposant compris entre -1 et 1.
    - *cas dénormal:* exposant compris entre -2 et -4. Le bit de l'exposant est
      implicite et seul les valeur de la mantisse compte. Or ici la mantisse à 3
      bits, donc le cas des dénormaux s'étend sur 3 bits d'exposant.
    - *cas infinis:* exposant < -4 et exposant > 1.

    #+CAPTION: Rappel des cas spéciaux
    #+NAME: fig:rappel_des_cas_speciaux
    #+ATTR_LATEX: :width 200px
    [[../ressources/special_case.png]]
   
*** Stuctures

    Tout d'abord nous avons remarqué que le backend utilise des structures pour
    faciliter la compréhension des calculs. Or les structures comportent des
    types scalaires. Il faut donc créer de nouvelles structures pour les types
    vectorielles que propose *clang*.

**** Code de la version scalaire pour les flottants

#+BEGIN_SRC c
typedef union {

  float f32;
  uint32_t u32;
  int32_t s32;

  /* Generic fields */
  float type;
  uint32_t u;

  struct {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
    uint32_t sign : FLOAT_SIGN_SIZE;
    uint32_t exponent : FLOAT_EXP_SIZE;
    uint32_t mantissa : FLOAT_PMAN_SIZE;
#endif
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    uint32_t mantissa : FLOAT_PMAN_SIZE;
    uint32_t exponent : FLOAT_EXP_SIZE;
    uint32_t sign : FLOAT_SIGN_SIZE;
#endif
  } ieee;

} binary32;
#+END_SRC

**** Pour la version vectorielles

      Comme nous ne pouvons pas faire des conditions de *preprocessing* dans les
      *macros* nous avons englobé nos *macros* dans les conditions de
      *preprocessing* afin de pouvoir définir les structures pour toutes les
      tailles de vecteur.

*** Types vectorielles

    Cependant au cours de l'écriture des structures vectorielles nous nous somme
    rendu compte qu'il nous fallais des vecteurs d'entiers signés de 64 bits
    pour les types flottants de 64 bits.

    C'est pourquoi nous les avons rajouté et que nous avons créer un fichier
    nommé *float_type.h* pour regroupé toutes les définitions des types
    vectorielles pour éviter de les redéfinir dans chaque fichier.

    Cependant nous n'avons pas réussis à introduire se fichier dans les
    *include* des wrappers. C'est pourquoi nous avons redéfini les types dans le
    fichier *interflop.h* car il est inclu dans le fichier final des wrappers.

*** Fonctions

    Il nous restait à vectoriser les fonctions du backends.

    Pour ce qui est des fonctions, elles utilisent elles aussi des types
    scalaires. Il faut donc créer des fonctions utilisant les types vectorielles.

**** Fonction principale

     Comme nous passons la taille du vecteur en paramètre il faut donc que l'on
     appelle la bonne fonction suivant la taille du vecteur. Le plus optimial
     dans notre cas était d'englober tout le code pour la même taille de vecteur
     afin de ne pas a devoir la retester par la suite.

     Pour ce qu'il est du calcul de l'opération originale, c'est le même procédé
     que pour le backend *ieee*.

**** Gestion des arrondis

    Ici commence la vectorisation du bakend.

    Comme dit dans le préambule un nombre flottant peut être dans 3 catégories:
    normal, dénormal et infini. Etant donné que les 2 derniers cas restent des
    cas rares dans les codes de calculs. Nous avons décidé de vectoriser que le
    cas des nombres flottants normal.

    Mais pour pouvoir vectoriser il faut que tous les éléments de vecteurs aient
    le même comportement. C'est pourquoi on parcours une fois le vecteur élément
    par élément pour s'assurer que tout les éléments soit des nombres normaux.

    Si il s'avère qu'il y ai 1 nombre dénormal et 7 nombres normaux dans un
    vecteur de 8 flottants simple précision. Alors on reparcours le vecteurs
    pour gérer les 7 nombres normaux qui n'ont pas encore été traités.

    ici exemple cas 1 dénormal et 7 normal
    ici exemple cas full normal

    _Complexité:_
    - cas *size* nombres infini : O(2n)
    - cas *size* nombres dénormal : O(3n)
    - cas *size* nombres normal : O(3n)
    - sinon : O(4n)

    Dans le code nous voyons qu'il utilise 2 fonctions pour gérer le cas des
    nombres normaux, une avec la calcul d'une erreur absolue et l'autre sans. Il
    faut donc vectoriser ces 2 fonctions.

**** Cas des nombres normaux
***** Normal
***** Absolute error
**** Cas des nombres normaux

     Pour vectoriser la fonction qui calcul les arrondis pour les nombres normaux
     il suffit d'utiliser les opérations avec des types vectorielles de *clang*.
    
#+BEGIN_SRC c
/**
 * Macro which define vector function to round binary32 normal
 */
#define define_round_binary32_normal_vector(size)                              \
  void round_binary32_normal_x##size(float *x, int##size precision) {          \
    float##size a = *(float##size *)x;                                         \
    /* build 1/2 ulp and add it  before truncation for faithfull rounding */   \
                                                                               \
    /* generate a mask to erase the last 23-VPRECLIB_PREC bits, in other words,\
       there remain VPRECLIB_PREC bits in the mantissa */                      \
    const int##size mask = 0xFFFFFFFF << (FLOAT_PMAN_SIZE - precision);        \
                                                                               \
    /* position to the end of the target prec-1 */                             \
    const int##size target_position = FLOAT_PMAN_SIZE - precision - 1;         \
                                                                               \
    binary32_float##size b32x = {.f32 = a};                                    \
    b32x.ieee.mantissa = 0;                                                    \
    binary32_float##size half_ulp = {.f32 = a};                                \
    half_ulp.ieee.mantissa = (1 << target_position);                           \
                                                                               \
    b32x.f32 = a + (half_ulp.f32 - b32x.f32);                                  \
    b32x.u32 &= mask;                                                          \
    x = (float *)&a;                                                           \
  }

/* Using above macro */
define_round_binary32_normal_vector(2);
define_round_binary32_normal_vector(4);
define_round_binary32_normal_vector(8);
define_round_binary32_normal_vector(16);
#+END_SRC

**** Cas des nombres normaux avec erreurs absolue

    Ici aussi on a opter pour la même technique de vectorisation. Comme on ne
    peut vectoriser le calcul que si tout les éléments du vecteurs ont le même
    comportement, on a choisis de vectoriser lorsque l'on se trouve dans le cas
    des nombres normaux. Car c'est le cas le plus fréquents.

    On parcours la aussi le vecteur éléments par éléments pour savoir si un
    élément du vecteur est en dessous de l'erreur absolue fixé. Si aucun élément
    n'est en dessous alors ils sont tous normaux et on peut vectoriser. Sinon on
    re-parcours le vecteur pour calculer les éléments normaux.

    _Complexité:_
    - cas *0* ou *size* éléments en dessous de la valeur absolue fixé : O(n)
    - cas entre *1* et *size - 1* éléments en dessous de la valeur absolue fixé :
      O(2n)

#+BEGIN_SRC c
#define define_handle_binary32_vector_normal_absErr(size)                      \
  void handle_binary32_normal_absErr_x##size(float *a,                         \
                                             int##size aexp,                   \
                                             int binary32_precision,           \
                                             t_context *currentContext) {      \
                                                                               \
    /* absolute error mode, or both absolute and relative error modes */       \
    int##size expDiff = aexp - currentContext->absErr_exp;                     \
    float##size retVal;                                                        \
    int##size set = 0;                                                         \
    int count = 0;                                                             \
                                                                               \
    for (int i = 0; i < size; i++) {                                           \
      if (expDiff[i] < -1) {                                                   \
        /* equivalent to underflow on the precision given by absolute error */ \
        a[i] = 0;                                                              \
        set[i] = 1;                                                            \
        count++;                                                               \
      } else if (expDiff[i] == -1) {                                           \
        /* case when the number is just below the absolute error threshold,    \
           but will round to one ulp on the format given by the absolute error;\
           this needs to be handled separately, as round_binary32_normal cannot\
           generate this number */                                             \
        a[i] = copysignf(exp2f(currentContext->absErr_exp), a[i]);             \
        set[i] = 1;                                                            \
        count++;                                                               \
      }                                                                        \
    }                                                                          \
                                                                               \
    if (count == 0) { /* we can vectorize */                                   \
      /* normal case for the absolute error mode */                            \
      int##size binary32_precision_adjusted =                                  \
        compute_absErr_vprec_binary32_x##size(false, currentContext, expDiff,  \
                                      binary32_precision);                     \
      round_binary32_normal_x##size(a, binary32_precision_adjusted);           \
    } else if (count == size) { /* all vector is set */                        \
      return;                                                                  \
    } else { /* we can't vectorize */                                          \
      for (int i = 0; i < size; i++) {                                         \
        if (!set[i]) {                                                         \
          int binary32_precision_adjusted =                                    \
            compute_absErr_vprec_binary32(false, currentContext, expDiff[i],   \
                                          binary32_precision);                 \
          round_binary32_normal_x(a[i], binary32_precision_adjusted);          \
        }                                                                      \
      }                                                                        \
    }                                                                          \
  }
#+END_SRC
>>>>>>> 810b0c3054062696957752c0a26b9186b3bebceb
