\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphics}
\usepackage{framed}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usetheme{Warsaw}

\title[Support pour Verificarlo]{Support de MPI/OpenMP et de la vectorisation dans Verificarlo}
\subtitle{Master Calcul Haute Performance et Simulation}

\author[Hery, Ali, Nicolas]{Hery ANDRIANANTENAINA \\ Ali LAKBAL \\ Nicolas BOUTON}

\institute{\textbf{Encadrant:} Eric PETIT}

\date{Année 2020-2021}

\begin{document}

\maketitle

\begin{frame}{Verificarlo}

  \begin{itemize}
  \item Compilateur: \textbf{ Clang et llvm} 
  \item Domaine d'utilisation: \textbf{ Instrumentation des opérations flottantes}
  \end{itemize}
  
  \textbf{1. Vectorisation dans le calcul scientifique}
  
\end{frame}
\begin{frame}{Vectorisation}
\textbf{1.Introduction :}
  \begin{itemize}
        \item \textbf{Compilateur:} \textit{ Clang et gcc} 
        \item \textbf{probleme:} \textit{ Etant donné que notre encadrant nous a dit que le support de
gcc était éphémère dû à une dépendance avec fortran}
         \item \textbf{solutions : } \textit{supporter les types vectoriels de clang et non pas ceux de gcc. }
         \item \textbf{test: } \textit{ pour tester il faut bien configurer \textbf{verificarlo} avec \textbf {clang} pour le C et C++ avec la commande suivante : }
         \end{itemize}
         \begin{center}
        \textbf{\color{blue} ./configure --without-flang CC=clang CXX=clang++ }      
          \end{center}
     
    
\end{frame}

\begin{frame}{Vectorisation}
\textbf{2.Tests :}
  \begin{itemize}
        \item\textit{ Suivre le fonctionnement de test que
Verificarlo a commencé à implémenter. } 
         \item\textit{Nous avont testé si les résultats obtenus lors de la compilation et de l’exécution sont exactes.} 
        
         \item \textit{Les tests sont principale-
ment écrient en bash, avec un code de test écris en c et un code python}  
         \item \textit{Les tests se trouvent dans
le répertoire \textbf{ tests/test-vector-instrumentation/}.} 
         \end{itemize}
\end{frame}


\begin{frame}{Vectorisation}
\textbf{2.Tests :}
  \begin{itemize}
        \item\textit{Donc en genéral nous avons effectué des tests sur les operations arithmetique vectorielles avec les jeux d'instruction sse ,avx et avx512, et s'assurer du bon fonctionnement. } 
         \item\textit{Nous avont testé si les résultats obtenus lors de la compilation et de l’exécution sont exactes.} 
        
         \item \textit{Nous avos efféctué trois sous tests : le bon resultat des opérations vectorielles ,l'appel aux probes vectorielles et l'utilisation des jeux d'instructions vectorielles .}  
         
         \end{itemize}
         \end{frame}
\begin{frame}{Vectorisation}         
\textbf{2.1:le bon resultat des opérations vectorielles}
  \begin{itemize}
        \item\textit{Dans ce cas nous avons testé sur les differents backends, les differentes operation vectorielles avec les vecteurs de taille differente sur les précisions qu'on a choisit (float et double);
        et on a deduit que les résultats retournés sont vrai
        } 
        \end{itemize}
\end{frame}

\begin{frame}{Vectorisation}         
\textbf{2.2:l'appel des probes vectorielles}
  \begin{itemize}
        \item\textit{Nous avons généré le fichier intermédiaire pendant la compilation avec la commande : \textbf{\color{blue} –save-temps }
        \item\textit{une foit le fichier généré , on remarque que on a effectivement fait appel à notre probe vectorielle}
        
        } 
        \end{itemize}
        
\end{frame}

\begin{frame}{Vectorisation}         
\textbf{2.3:Utilisation des jeux d’instructions vectorielles}
  \begin{itemize}
     \item\textit{Dans verificarle, les instructions vectorielles pour les opérations arithmetiques sont présentées par la concaténation suivante :operation##vectoriel##précision } 
      \item\textit{elle s'utilise sur les registres \textbf{xmm,ymm,zmm } associés respectivement au jeux d'instructions \textbf{sse,avx,avx512} } 
      \textit{si on prend comme exemple : \textbf{mulps} avec un registre \textbf{xmm} c'est une instruction vectorisée} 
   \end{itemize}
\end{frame}

\begin{frame}{Vectorisation}         

  \begin{itemize}
   \item\textit{les vecteurs 256 et 512 bits sont déja inclus et supportés} 
   \item\textit{Dans la premieres version de verificarlo , les probes vecctorielles sont implémentées mais elles appelent toujours la version scalaire.donc de notre coté on a rajouté des fonction vectorielles dans les backends que nous avont appelé à partir des wrappers dans les probes,dans le fichier \textbf{src/vfcwrapper/main.c} } 
   \end{itemize}
\end{frame}

\begin{frame}{Vectorisation}         

  \begin{itemize}
  \item\textit{ensuite il faut ajouter les fonctions vectorielles dans l'interface qui se trouve dans le fichier \textbf{src/common/interflop.h}} 
 \item\textit{Nous avons cherché et tésté comment minimiser le nombre des fonction ,donc la meilleur solution q'uon a trouvé est de mettre la taille des vecteur en paramétre; ca nous a minimisé le nombre à 8 fonctions vectorielles en tout}
 \item\textit{Comme nous passons la taille en argument, il faudra tester la taille pour permettre à clang d’effectuer une opération vectorielle en changeant le type de notre tableau dans le bon type vectorielles de clang.}
 
 \item\textit{De plus nous avons déplacés la définitions des types vectorielles dans le fichier src/common/inteflop.h .}
   \end{itemize}
\end{frame}
\begin{frame}{Changements aux niveaux des backends}

  \begin{block}{Fonctions vectorielles en mode scalaire}
    Tous les backends
  \end{block}

  \begin{block}{Fonctions vectorielles en mode vectoriel}
    \begin{itemize}
    \item ieee
    \item vprec
    \end{itemize}
  \end{block}

\end{frame}

\begin{frame}{Changements aux niveaux du backend vprec}

  \begin{block}{Fonctionnement du backend}
    \begin{itemize}
    \item norme IEEE754
    \item fonction de debug
    \end{itemize}
  \end{block}

  \begin{block}{Opérande constantes}
    \begin{itemize}
    \item avertissement de clang sur les types des paramètres de fonction
    \item ajout d'un pragma pour retirer l'avertissement
    \end{itemize}
  \end{block}

\end{frame}

\begin{frame}{Changements aux niveaux du backend vprec}

  \begin{block}{Fonctionnement du backend}
    \begin{itemize}
    \item nombres fini et infini
    \item nombres normaux et dénormaux
    \end{itemize}
  \end{block}

  \begin{figure}
    \centering
    \includegraphics[width=200px]{../ressources/IEEE754_simple_precision.png}
    \caption{\label{fig:ieee_simple_precision}Représentation d'un nombre flottant simple précision}
  \end{figure}

\end{frame}

\begin{frame}{Compilation}

  \begin{block}{Ajout dans verificarlo}
    Compilation des \textbf{wrappers} et des \textbf{backends} avec le drapeau
    \textbf{-march=native}
  \end{block}

\end{frame}

\begin{frame}{Problèmes rencontrés}

  \begin{block}{Types vectorielles}
    Vecteur de 4 double précision
  \end{block}

  \begin{block}{Jeu d'instruction disponnible}
    SSE
  \end{block}

  \begin{block}{Clang}
    Utilise 4 addition vectoriel SSE
  \end{block}

  \begin{block}{Verificarlo}
    \begin{itemize}
    \item Backend: vectorisé comme pour clang
    \item Problème: vecteur passé par registre entre les modules
    \end{itemize}
  \end{block}

\end{frame}

\begin{frame}{Conclusion}

  \begin{block}{Cours en relation}
    Architecture Parallèle
  \end{block}

\end{frame}

\end{document}
